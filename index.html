<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EpubCraft · Editor EPUB</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    :root {
      --bg: #f3f4f6;
      --surface: #fff;
      --text: #111827;
      --muted: #6b7280;
      --line: #e5e7eb;
      --primary: #2563eb;
      --ok: #059669;
      --danger: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 16px;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
    }
    h1 { margin: 0; font-size: 28px; }
    h2 { margin: 0 0 12px; font-size: 18px; }
    .sub { color: var(--muted); margin-top: 8px; font-size: 14px; }
    .grid { display: grid; gap: 12px; }
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .btn {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 9px 14px;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    .btn.primary { background: var(--primary); color: #fff; border-color: var(--primary); }
    .btn.ok { background: var(--ok); color: #fff; border-color: var(--ok); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    input[type="file"], input[type="text"] {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      width: 100%;
    }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid var(--line); padding: 8px; text-align: left; vertical-align: middle; }
    th { font-size: 13px; color: var(--muted); font-weight: 600; }
    .small { font-size: 12px; color: var(--muted); }
    .status { font-size: 14px; color: var(--muted); white-space: pre-wrap; }
    .chapter-list {
      max-height: 260px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
    }
    .chapter-item {
      padding: 8px 10px;
      border-bottom: 1px solid var(--line);
      display: grid;
      gap: 4px;
    }
    .chapter-item:last-child { border-bottom: 0; }
    .chapter-title { font-size: 14px; font-weight: 600; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>EpubCraft <span class="small">Editor EPUB</span></h1>
      <p class="sub">Carrega un EPUB, posa-li portada, afegeix títols de capítol si falten, crea/edita l'índex i descarrega l'EPUB modificat.</p>
    </div>

    <div class="card grid cols-2">
      <div class="grid">
        <h2>1) Carregar EPUB</h2>
        <input id="epubFile" type="file" accept=".epub" />
        <div class="status" id="loadStatus">Encara no s'ha carregat cap fitxer.</div>
      </div>
      <div class="grid">
        <h2>2) Portada</h2>
        <input id="coverFile" type="file" accept="image/png,image/jpeg,image/webp" />
        <div class="row">
          <button class="btn" id="applyCoverBtn" disabled>Aplicar portada</button>
        </div>
        <div class="small">S'afegeix dins l'EPUB i s'actualitza la metadata de portada.</div>
      </div>
    </div>

    <div class="card grid cols-2">
      <div class="grid">
        <h2>3) Títols de capítol</h2>
        <div class="row">
          <button class="btn" id="addMissingHeadingsBtn" disabled>Afegir H1 on falti</button>
        </div>
        <div class="small">Inserta un títol al principi del capítol si no existeix cap &lt;h1&gt;.</div>
        <div class="chapter-list" id="chapterList"></div>
      </div>
      <div class="grid">
        <h2>4) Índex editable</h2>
        <table>
          <thead>
            <tr><th style="width:44%">Títol</th><th style="width:36%">Href</th><th>Accions</th></tr>
          </thead>
          <tbody id="tocBody"></tbody>
        </table>
        <div class="row">
          <button class="btn" id="addTocEntryBtn" disabled>Afegir entrada</button>
          <button class="btn ok" id="rebuildNavBtn" disabled>Regenerar índex</button>
        </div>
      </div>
    </div>

    <div class="card row">
      <button class="btn primary" id="downloadBtn" disabled>Descarregar EPUB editat</button>
      <div class="status" id="actionStatus">.</div>
    </div>
  </div>

<script>
  const state = {
    zip: null,
    opfPath: null,
    opfDoc: null,
    navPath: null,
    ncxPath: null,
    manifestById: {},
    spineIds: [],
    toc: [],
    chapters: []
  };

  const loadStatus = document.getElementById('loadStatus');
  const actionStatus = document.getElementById('actionStatus');
  const tocBody = document.getElementById('tocBody');
  const chapterList = document.getElementById('chapterList');

  const epubFileInput = document.getElementById('epubFile');
  const coverFileInput = document.getElementById('coverFile');
  const applyCoverBtn = document.getElementById('applyCoverBtn');
  const addMissingHeadingsBtn = document.getElementById('addMissingHeadingsBtn');
  const addTocEntryBtn = document.getElementById('addTocEntryBtn');
  const rebuildNavBtn = document.getElementById('rebuildNavBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  epubFileInput.addEventListener('change', (e) => loadEpub(e.target.files[0]));
  applyCoverBtn.addEventListener('click', applyCover);
  addMissingHeadingsBtn.addEventListener('click', addMissingHeadings);
  addTocEntryBtn.addEventListener('click', () => {
    state.toc.push({ title: 'Nou capítol', href: state.chapters[0]?.href || '' });
    renderToc();
  });
  rebuildNavBtn.addEventListener('click', rebuildIndexFiles);
  downloadBtn.addEventListener('click', downloadEpub);

  function setEnabled(v) {
    [applyCoverBtn, addMissingHeadingsBtn, addTocEntryBtn, rebuildNavBtn, downloadBtn].forEach(btn => btn.disabled = !v);
  }

  async function loadEpub(file) {
    if (!file) return;
    try {
      state.zip = await JSZip.loadAsync(file);
      const containerXml = await state.zip.file('META-INF/container.xml')?.async('string');
      if (!containerXml) throw new Error('No s\'ha trobat META-INF/container.xml');
      const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
      state.opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
      if (!state.opfPath) throw new Error('No s\'ha trobat el fitxer OPF.');

      const opfXml = await state.zip.file(state.opfPath).async('string');
      state.opfDoc = new DOMParser().parseFromString(opfXml, 'application/xml');
      parseManifestAndSpine();
      await loadTocFromBook();
      await loadChapters();
      renderToc();
      renderChapters();
      setEnabled(true);
      loadStatus.textContent = `EPUB carregat correctament. OPF: ${state.opfPath}. Capítols detectats: ${state.chapters.length}.`;
      actionStatus.textContent = 'Projecte llest per editar.';
    } catch (err) {
      setEnabled(false);
      loadStatus.textContent = 'Error carregant EPUB: ' + err.message;
    }
  }

  function parseManifestAndSpine() {
    state.manifestById = {};
    state.spineIds = [];
    [...state.opfDoc.querySelectorAll('manifest > item')].forEach(item => {
      state.manifestById[item.getAttribute('id')] = {
        id: item.getAttribute('id'),
        href: item.getAttribute('href'),
        mediaType: item.getAttribute('media-type') || ''
      };
    });
    [...state.opfDoc.querySelectorAll('spine > itemref')].forEach(it => {
      const idref = it.getAttribute('idref');
      if (idref) state.spineIds.push(idref);
    });
  }

  async function loadTocFromBook() {
    state.toc = [];
    state.navPath = null;
    state.ncxPath = null;

    const navItem = Object.values(state.manifestById).find(item => item.mediaType === 'application/xhtml+xml' && /nav/i.test(item.id));
    const ncxItem = Object.values(state.manifestById).find(item => item.mediaType === 'application/x-dtbncx+xml');

    if (navItem) {
      state.navPath = resolvePath(state.opfPath, navItem.href);
      const navXml = await state.zip.file(state.navPath)?.async('string');
      if (navXml) {
        const navDoc = new DOMParser().parseFromString(navXml, 'application/xhtml+xml');
        navDoc.querySelectorAll('nav li > a').forEach(a => {
          state.toc.push({ title: a.textContent.trim() || 'Sense títol', href: a.getAttribute('href') || '' });
        });
      }
    }

    if (state.toc.length === 0 && ncxItem) {
      state.ncxPath = resolvePath(state.opfPath, ncxItem.href);
      const ncxXml = await state.zip.file(state.ncxPath)?.async('string');
      if (ncxXml) {
        const ncxDoc = new DOMParser().parseFromString(ncxXml, 'application/xml');
        ncxDoc.querySelectorAll('navMap navPoint').forEach(np => {
          state.toc.push({
            title: np.querySelector('text')?.textContent?.trim() || 'Sense títol',
            href: np.querySelector('content')?.getAttribute('src') || ''
          });
        });
      }
    }

    if (state.toc.length === 0) {
      state.toc = state.spineIds
        .map((idref, idx) => ({
          title: `Capítol ${idx + 1}`,
          href: state.manifestById[idref]?.href || ''
        }))
        .filter(x => x.href);
    }
  }

  async function loadChapters() {
    state.chapters = [];
    for (const idref of state.spineIds) {
      const item = state.manifestById[idref];
      if (!item || !item.mediaType.includes('xhtml')) continue;
      const chapterPath = resolvePath(state.opfPath, item.href);
      const xml = await state.zip.file(chapterPath)?.async('string');
      if (!xml) continue;
      const doc = new DOMParser().parseFromString(xml, 'application/xhtml+xml');
      const h1 = doc.querySelector('h1');
      const guessedTitle = h1?.textContent?.trim() || state.toc.find(t => stripAnchor(t.href) === stripAnchor(item.href))?.title || fileName(item.href);
      state.chapters.push({
        idref,
        href: item.href,
        path: chapterPath,
        title: guessedTitle,
        hasH1: !!h1
      });
    }
  }

  function renderToc() {
    tocBody.innerHTML = '';
    state.toc.forEach((entry, index) => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td><input type="text" value="${escapeHtml(entry.title)}" data-k="title" data-i="${index}"></td>
        <td><input type="text" value="${escapeHtml(entry.href)}" data-k="href" data-i="${index}"></td>
        <td>
          <div class="row">
            <button class="btn" data-act="up" data-i="${index}">↑</button>
            <button class="btn" data-act="down" data-i="${index}">↓</button>
            <button class="btn" data-act="del" data-i="${index}">Eliminar</button>
          </div>
        </td>`;
      tocBody.appendChild(row);
    });

    tocBody.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', (e) => {
        const i = Number(e.target.dataset.i);
        const k = e.target.dataset.k;
        state.toc[i][k] = e.target.value;
      });
    });

    tocBody.querySelectorAll('button[data-act]').forEach(btn => {
      btn.addEventListener('click', () => {
        const i = Number(btn.dataset.i);
        const act = btn.dataset.act;
        if (act === 'del') state.toc.splice(i, 1);
        if (act === 'up' && i > 0) [state.toc[i - 1], state.toc[i]] = [state.toc[i], state.toc[i - 1]];
        if (act === 'down' && i < state.toc.length - 1) [state.toc[i], state.toc[i + 1]] = [state.toc[i + 1], state.toc[i]];
        renderToc();
      });
    });
  }

  function renderChapters() {
    chapterList.innerHTML = '';
    state.chapters.forEach((ch, idx) => {
      const div = document.createElement('div');
      div.className = 'chapter-item';
      div.innerHTML = `<div class="chapter-title">${idx + 1}. ${escapeHtml(ch.title)}</div>
      <div class="small">${escapeHtml(ch.href)} · H1: ${ch.hasH1 ? 'sí' : 'no'}</div>`;
      chapterList.appendChild(div);
    });
  }

  async function addMissingHeadings() {
    let changed = 0;
    for (const ch of state.chapters) {
      if (ch.hasH1) continue;
      const xml = await state.zip.file(ch.path).async('string');
      const doc = new DOMParser().parseFromString(xml, 'application/xhtml+xml');
      const body = doc.querySelector('body');
      if (!body) continue;
      const h1 = doc.createElement('h1');
      h1.textContent = ch.title || fileName(ch.href);
      body.insertBefore(h1, body.firstChild);
      state.zip.file(ch.path, new XMLSerializer().serializeToString(doc));
      ch.hasH1 = true;
      changed++;
    }
    renderChapters();
    actionStatus.textContent = `Títols afegits: ${changed}.`;
  }

  async function applyCover() {
    const file = coverFileInput.files?.[0];
    if (!file) {
      actionStatus.textContent = 'Selecciona una imatge de portada.';
      return;
    }
    const ext = file.name.split('.').pop().toLowerCase();
    const mime = file.type || (ext === 'png' ? 'image/png' : ext === 'webp' ? 'image/webp' : 'image/jpeg');
    const coverFolder = baseDir(state.opfPath) + '/images';
    const coverRel = 'images/cover.' + (ext === 'jpeg' ? 'jpg' : ext);
    const coverPath = coverFolder + '/cover.' + (ext === 'jpeg' ? 'jpg' : ext);

    const arrayBuffer = await file.arrayBuffer();
    state.zip.file(coverPath.replace(/^\/+/, ''), arrayBuffer);

    const manifest = state.opfDoc.querySelector('manifest');
    let coverItem = state.opfDoc.querySelector('manifest > item[id="cover-image"]');
    if (!coverItem) {
      coverItem = state.opfDoc.createElement('item');
      coverItem.setAttribute('id', 'cover-image');
      manifest.appendChild(coverItem);
    }
    coverItem.setAttribute('href', coverRel);
    coverItem.setAttribute('media-type', mime);
    coverItem.setAttribute('properties', 'cover-image');

    const metadata = state.opfDoc.querySelector('metadata');
    let metaCover = state.opfDoc.querySelector('metadata > meta[name="cover"]');
    if (!metaCover) {
      metaCover = state.opfDoc.createElement('meta');
      metaCover.setAttribute('name', 'cover');
      metadata.appendChild(metaCover);
    }
    metaCover.setAttribute('content', 'cover-image');

    await saveOpf();
    actionStatus.textContent = 'Portada aplicada correctament.';
  }

  async function rebuildIndexFiles() {
    const navItem = ensureNavManifestItem();
    state.navPath = resolvePath(state.opfPath, navItem.getAttribute('href'));

    const navXhtml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><title>Índex</title></head>
<body>
  <nav epub:type="toc" id="toc">
    <h1>Índex</h1>
    <ol>
      ${state.toc.map(e => `<li><a href="${escapeAttr(e.href)}">${escapeHtml(e.title)}</a></li>`).join('\n      ')}
    </ol>
  </nav>
</body>
</html>`;
    state.zip.file(state.navPath, navXhtml);

    const ncxItem = Object.values(state.manifestById).find(item => item.mediaType === 'application/x-dtbncx+xml');
    if (ncxItem) {
      state.ncxPath = resolvePath(state.opfPath, ncxItem.href);
      const ncx = `<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head></head>
  <docTitle><text>Índex</text></docTitle>
  <navMap>
    ${state.toc.map((e, i) => `<navPoint id="navPoint-${i + 1}" playOrder="${i + 1}"><navLabel><text>${escapeXml(e.title)}</text></navLabel><content src="${escapeAttr(e.href)}"/></navPoint>`).join('')}
  </navMap>
</ncx>`;
      state.zip.file(state.ncxPath, ncx);
    }

    await saveOpf();
    actionStatus.textContent = 'Índex regenerat (nav + ncx si existia).';
  }

  function ensureNavManifestItem() {
    let navItem = state.opfDoc.querySelector('manifest > item[properties="nav"]');
    if (!navItem) {
      const manifest = state.opfDoc.querySelector('manifest');
      navItem = state.opfDoc.createElement('item');
      navItem.setAttribute('id', 'nav');
      navItem.setAttribute('href', 'nav.xhtml');
      navItem.setAttribute('media-type', 'application/xhtml+xml');
      navItem.setAttribute('properties', 'nav');
      manifest.appendChild(navItem);
      if (!state.spineIds.includes('nav')) {
        const spine = state.opfDoc.querySelector('spine');
        const itemref = state.opfDoc.createElement('itemref');
        itemref.setAttribute('idref', 'nav');
        spine.insertBefore(itemref, spine.firstChild);
        state.spineIds.unshift('nav');
      }
    }
    parseManifestAndSpine();
    return navItem;
  }

  async function saveOpf() {
    state.zip.file(state.opfPath, new XMLSerializer().serializeToString(state.opfDoc));
  }

  async function downloadEpub() {
    await saveOpf();
    const blob = await state.zip.generateAsync({ type: 'blob' });
    saveAs(blob, 'epub-editat.epub');
    actionStatus.textContent = 'EPUB generat i descarregat.';
  }

  function resolvePath(fromFile, rel) {
    const fromDir = baseDir(fromFile);
    const joined = (fromDir ? fromDir + '/' : '') + rel;
    const out = [];
    joined.split('/').forEach(p => {
      if (!p || p === '.') return;
      if (p === '..') out.pop();
      else out.push(p);
    });
    return out.join('/');
  }

  function baseDir(path) {
    const i = path.lastIndexOf('/');
    return i >= 0 ? path.slice(0, i) : '';
  }
  function stripAnchor(href) { return (href || '').split('#')[0]; }
  function fileName(path) { return (path || '').split('/').pop() || 'capitol'; }
  function escapeHtml(str) { return (str || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
  function escapeAttr(str) { return escapeHtml(str).replace(/'/g, '&apos;'); }
  function escapeXml(str) { return (str || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&apos;'}[c])); }
</script>
</body>
</html>
